{
  "meta": {
    "title": "Jin Hwan - Resume",
    "description": "웹·온디바이스 LLM·실시간 스트리밍·로보틱스를 '출시 가능한 제품'으로 잇는 풀스택 엔지니어.",
    "portfolioTitle": "Portfolio - Jin Hwan",
    "portfolioDescription": "Software 3.0 - The Era of LLM-Programmable Systems"
  },
  "navbar": {
    "resume": "이력서",
    "portfolio": "포트폴리오",
    "side": "사이드",
    "theme": "테마",
    "language": "언어",
    "ko": "한국어",
    "en": "English"
  },
  "resume": {
    "downloadPDF": "인쇄용 PDF 다운로드",
    "downloadFilename": "진환_이력서.pdf",
    "hero": {
      "title": "풀스택 엔지니어 진환.",
      "location": "경기도 안산, 대한민국",
      "birthDate": "1995년 03월 04일",
      "age": "만 30세",
      "gender": "남성 (He, Him)",
      "description": "웹·온디바이스 LLM·실시간 스트리밍·로보틱스를 '출시 가능한 제품'으로 잇는 풀스택 엔지니어.",
      "summary": "웹·온디바이스 LLM·실시간 스트리밍·로보틱스를 '출시 가능한 제품'으로 잇는 풀스택 엔지니어. 모바일 온디바이스 AI와 실시간 미디어/로보틱스를 잇는 브릿지·스트리밍·저지연 제어 전문성 보유. 프라이버시 중심 아키텍처와 PWA/엣지 배포로 사용자 경험과 성능을 동시에 달성. 제품 초기화부터 배포/운영 자동화까지 엔드투엔드 오너십으로 다수 프로젝트 출시 및 운영 경험 보유."
    },
    "sections": {
      "about": "소개",
      "work": "경력",
      "education": "학력",
      "skills": "기술 스택",
      "projects": "프로젝트",
      "projectsSubtitle": "사이드 프로젝트 이력",
      "projectsDescription": "다양한 사이드 프로젝트 진행, 새로운 기술 탐구 및 아이디어 실현.",
      "publications": "출판",
      "publicationsSubtitle": "출판 이력",
      "publicationsDescription": "기술과 개발에 대한 인사이트를 담은 저서.",
      "hackathons": "수상 및 자격증",
      "hackathonsSubtitle": "수상 이력",
      "hackathonsDescription": "다양한 공모전과 대회에서 수상한 경력과 보유 자격증.",
      "contact": "연락처"
    },
    "publication": {
      "author": "저자",
      "publisher": "출판사",
      "publishDate": "출간일",
      "ebookLink": "E-Book 링크"
    },
    "contact": {
      "kakao": "카카오톡"
    },
    "portfolioLink": "포트폴리오 읽기",
    "sideProjectsLink": "사이드 프로젝트 보기"
  },
  "data": {
    "location": "대한민국",
    "birthDate": "",
    "age": "",
    "gender": "",
    "description": "풀스택 엔지니어를 지향하며, 실제 테스트와 측정을 통해 성능 개선을 확인하는 과정에 큰 즐거움을 느낍니다.",
    "summary": "풀스택 엔지니어를 지향하며, 실제 테스트와 측정을 통해 성능 개선을 확인하는 과정에 큰 즐거움을 느낍니다. 새로운 기술과 다양한 지식을 직접 적용해보고, 이해되지 않던 개념을 하나씩 명확하게 깨닫는 탐구 과정을 좋아합니다.",
    "work": {
      "eeboon": {
        "company": "주식회사이분",
        "title": "풀스택 개발자",
        "location": "대한민국",
        "start": "2025년 3월",
        "end": "현재",
        "description": "회사 프로덕트 풀스택 개발 및 유지보수 담당. 클라이언트 웹 어플리케이션, 관리자 대시보드, API 서비스 관리자 대시보드 개발 및 유지보수. Figma Plugin 유지보수. 프로덕트 전체 CI/CD 신규 구현 및 유지보수. 운영 환경 리팩토링하여 불필요한 코드, 저장소, AWS 클라우드 자원 등을 정리하여 가시성과 유지보수성 향상. API 응답시간 단축(수분 → 8초 이내). AI 모델 서빙 서버 최적화(24초 → 4초). pptx-automizer 라이브러리 분석 및 다중 요소 수정 로직 추가. AI 모델 서빙 서버를 레이어드 아키텍처 기반으로 리팩토링. Docker Compose + ECR 환경 최적화."
      },
      "tax": {
        "company": "함께하는 세무회계",
        "title": "백엔드 개발자",
        "location": "대한민국",
        "start": "2025년 2월",
        "end": "2025년 3월",
        "description": "세무 회계 SaaS 백엔드 개발. Nest.js 백엔드 개발 담당. 다양한 계산 규칙(공제 항목, 비율 계산, 금액 범위 조건 등)을 반영한 비즈니스 로직 구현 및 모듈화."
      },
      "megapress": {
        "company": "주식회사 메가프레스",
        "title": "백엔드 개발자",
        "location": "대한민국",
        "start": "2023년 4월",
        "end": "2025년 1월",
        "description": "Express에서 NestJS로 마이그레이션하여 표준화된 개발 환경 및 유지보수성 향상. 헥사고널 아키텍처 적용. Next.js/NestJS 서비스를 Turborepo + pnpm 기반 모노레포로 통합하여 공통 모듈 재사용 체계 구축 및 중복 코드 제거. ngrinder를 사용한 부하 테스트로 서비스 안정성 체크. AWS 인프라 관리(EC2 모니터링, 신규 사이트 도메인 세팅)."
      },
      "buymeslim": {
        "company": "바이미스림",
        "title": "풀스택 개발자(프리랜서)",
        "location": "대한민국",
        "start": "2024년 9월",
        "end": "2025년 11월",
        "description": "의류 피팅 예약 어플 개발 및 유지보수. Python/Django를 통한 백엔드 서버 개발, DRF를 사용한 REST API 처리, 로그인 및 예약 관련 CRUD 구현. 스마트스토어 크롤링으로 고객 편의성 향상. Flutter를 사용한 크로스플랫폼 앱 개발, Provider 패키지를 활용한 상태관리, MVVM 디자인 패턴 적용. Next.js를 사용한 admin 페이지 개발."
      }
    },
    "education": {},
    "projects": {},
    "hackathons": {},
    "publications": {}
  },
  "portfolio": {
    "downloadPDF": "인쇄용 PDF 다운로드",
    "downloadFilename": "진환_포트폴리오.pdf",
    "pageNumber": "페이지"
  },
  "notFound": {
    "title": "페이지를 찾을 수 없음",
    "description": "요청하신 페이지가 존재하지 않거나 이동됨.",
    "goHome": "홈으로 돌아가기",
    "goBack": "이전 페이지로",
    "contactAdmin": "문제가 계속되면 관리자에게 문의 바람."
  },
  "slides": {
    "llamiApp": {
      "problem": {
        "title": "라미앱 개발 배경",
        "subtitle": "비즈니스 문제 정의",
        "period": "진행기간",
        "periodValue": "2025.05.04 ~ 2025.06.17 출시",
        "role": "맡은 역할",
        "roleValue": "CTO 및 리드 개발자",
        "contribution": "프로젝트 기여도",
        "contributionValue": "30% (네이티브 앱 아키텍팅 및 PoC 구현)",
        "businessProblem": "비즈니스 문제",
        "problem1": "• 결제 페이지에서 <span class=\"font-bold text-red-700 dark:text-red-400\">95% 이탈률</span>",
        "problem2": "• 고객 인터뷰: \"무료 AI 서비스가 많아 결제 망설임\"",
        "problem3": "• CAC가 투자자 요구 대비 <span class=\"font-bold text-red-700 dark:text-red-400\">5배 초과</span>",
        "problem4": "• 기존 AI 서비스 고정비 절감 방안은 대규모 서비스에만 특화",
        "quote": "\"AI 서비스 고정비를 획기적으로 줄일 새로운 방안이 요구됨\""
      },
      "design": {
        "title": "라미앱 설계",
        "subtitle": "요구사항과 해결 방안",
        "requirement1": "요구사항 1: 고정비 제로화",
        "solution1": "→ 온디바이스 AI 앱 설계로 서버 비용 완전 제거",
        "requirement2": "요구사항 2: 웹 팀으로 앱 개발",
        "solution2": "→ Expo 웹뷰 + 핵심 모듈만 React Native/C++ 하이브리드 설계",
        "requirement3": "요구사항 3: 자체 AI 모델 운용",
        "solution3": "→ Gemma3 SLM 파인튜닝 후 GGUF 모델로 배포"
      },
      "implementation": {
        "title": "라미앱 구현",
        "subtitle": "기술적 도전과 해결",
        "coreTitle": "핵심 구현 사항",
        "item1Title": "1. 상태 브릿지 시스템",
        "item1Detail1": "• Observable State 기반 Expo ↔ React Native 상태 공유",
        "item1Detail2": "• 점진적 마이그레이션 가능한 아키텍처",
        "item2Title": "2. AI 모델 업데이트 시스템",
        "item2Detail1": "• Cloudflare R2 기반 GGUF 모델 배포",
        "item2Detail2": "• 앱 재설치 없이 모델 업데이트 가능",
        "item3Title": "3. 크로스 플랫폼 AI 가속",
        "item3Detail1": "• llama.cpp 통한 iOS Metal GPU 가속",
        "item3Detail2": "• Android CPU 최적화 추론",
        "item4Title": "4. 개발 생산성 최적화",
        "item4Detail1": "• 웹 개발자가 네이티브 지식 없이 개발",
        "item4Detail2": "• 타입 안전성 보장된 브릿지 패턴",
        "decisionTitle": "기술적 의사결정",
        "decision1": "• React 컴포넌트로 빠른 MVP 구현 → 점진적 React Native 전환",
        "decision2": "• 브릿지 패턴 추상화로 중복 코드 60% 감소",
        "decision3": "• EAS Build 자동화로 빌드 시간 50% 단축",
        "decision4": "• Observable 기반 상태 관리로 타입 안전성 확보"
      },
      "results": {
        "title": "라미앱 결과",
        "subtitle": "비즈니스 임팩트",
        "metric1Value": "0원",
        "metric1Title": "AI 고정비 달성",
        "metric1Desc": "100% 온디바이스 기술",
        "metric2Value": "500%",
        "metric2Title": "고객 참여도 향상",
        "metric2Desc": "유료 AI 대비 5배",
        "metric3Value": "2.6배",
        "metric3Title": "개발 생산성 향상",
        "metric3Desc": "MVP 6주 → 2.3주",
        "learningsTitle": "프로젝트를 통해 배운 점",
        "businessTitle": "비즈니스 임팩트",
        "business1": "• 기술적 제약을 비즈니스 기회로 전환",
        "business2": "• 온디바이스 AI로 고정비 제로화 달성",
        "business3": "• Cloudflare R2로 배포 비용 최적화",
        "technicalTitle": "기술적 의사결정",
        "technical1": "• 빠른 개발 vs 좋은 설계의 균형점 찾기",
        "technical2": "• 점진적 마이그레이션 전략의 중요성",
        "technical3": "• 팀 역량에 맞는 기술 스택 선택"
      }
    },
    "llamiRobotics": {
      "problem": {
        "title": "라미 로보틱스 - 4족보행 로봇",
        "subtitle": "DeepRobotics 로봇개 원격 제어 및 자율 주행 플랫폼",
        "period": "프로젝트 기간",
        "periodValue": "2025.07.16 ~ 2025.09.01 (중단)",
        "role": "역할",
        "roleValue": "CTO 및 리드 개발자",
        "contribution": "프로젝트 기여도",
        "contributionValue": "진환 50%: 딥로봇틱스 Lite3 로봇개 원격 제어 및 자율 주행 시스템 개발. WebRTC 기반 실시간 영상 스트리밍과 WebSocket 통신을 통한 로봇 제어, SLAM 기반 맵핑 및 경로 계획 알고리즘 구현",
        "challengesTitle": "핵심 기술 과제",
        "challenge1Title": "로봇 웹 통신 프로토콜 부재",
        "challenge1Desc": "딥로봇틱스 Lite3는 UDP 바이너리 프로토콜 사용, 공식 웹 SDK 없음",
        "challenge2Title": "실시간 영상 전송 지연",
        "challenge2Desc": "RTSP 스트림을 웹에서 직접 재생 불가, HLS는 3~5초 지연",
        "challenge3Title": "복잡한 환경에서의 경로 계획",
        "challenge3Desc": "장애물 회피, 작업 영역 제약, 선호 경로 등 다층 제약 조건 처리",
        "challenge4Title": "영상 품질 및 성능 문제",
        "challenge4Desc": "로봇 카메라의 불안정한 화이트밸런스, CPU 기반 영상 처리는 30fps에서 프레임 드롭 발생"
      },
      "design": {
        "title": "라미 로보틱스 설계",
        "subtitle": "핵심 설계 결정",
        "decision1": "UDP 기반 바이너리 프로토콜",
        "detail1": "로봇 제어 명령 및 상태 데이터 실시간 송수신",
        "decision2": "WebRTC 저지연 스트리밍",
        "detail2": "RTSP → H.264 RTP 트랜스코딩 → WebRTC 전송",
        "decision3": "SLAM 기반 맵핑 시스템",
        "detail3": "LiDAR 데이터 기반 실시간 환경 맵 생성",
        "decision4": "A* 경로 계획 알고리즘",
        "detail4": "다층 비용 맵 기반 최적 경로 탐색"
      },
      "implementation": {
        "title": "라미 로보틱스 구현",
        "subtitle": "기술적 도전과 해결",
        "challenge1Title": "도전 1: 바이너리 프로토콜 구현",
        "challenge1Situation": "상황: 공식 SDK 없이 바이너리 프로토콜 직접 구현 필요",
        "challenge1Action": "행동: Wireshark로 패킷 분석, 200+ 바이트 로봇 상태 데이터 파싱",
        "challenge1Impact": "영향: 실시간 양방향 통신 달성 (500ms 주기)",
        "challenge2Title": "도전 2: 저지연 영상 스트리밍",
        "challenge2Situation": "상황: RTSP를 웹에서 재생 불가, HLS는 3~5초 지연",
        "challenge2Action": "행동: FFmpeg로 RTSP → H.264 RTP 트랜스코딩, mediasoup로 WebRTC 전송",
        "challenge2Impact": "영향: 지연 시간 3~5초 → 300~500ms (90% 감소)",
        "challenge3Title": "도전 3: 경로 계획 알고리즘",
        "challenge3Situation": "상황: 복잡한 환경에서 자율 주행 필요",
        "challenge3Action": "행동: 다층 비용 맵 생성, 8방향 이웃 탐색 A* 알고리즘 구현",
        "challenge3Impact": "영향: 4000×4000 가상 월드에서 경로 계획 평균 45ms",
        "challenge4Title": "도전 4: GPU 가속 영상 처리",
        "challenge4Situation": "상황: CPU 기반 영상 처리는 프레임 드롭 발생",
        "challenge4Action": "행동: WebGL Fragment Shader로 GPU 가속 구현",
        "challenge4Impact": "영향: 1920×1080 해상도 30fps 실시간 처리, CPU 사용률 5% 이하"
      },
      "results": {
        "title": "라미 로보틱스 결과",
        "subtitle": "비즈니스 임팩트 및 학습",
        "businessImpactTitle": "비즈니스 임팩트",
        "metric1Value": "90%",
        "metric1Title": "영상 지연 감소",
        "metric1Desc": "3~5초 → 300~500ms",
        "metric2Value": "45ms",
        "metric2Title": "경로 계획 속도",
        "metric2Desc": "실시간 대응 가능",
        "metric3Value": "30fps",
        "metric3Title": "영상 처리 성능",
        "metric3Desc": "CPU 5% 이하",
        "metric4Value": "500ms",
        "metric4Title": "제어 응답성",
        "metric4Desc": "실시간 양방향 통신",
        "technicalDecisionTitle": "기술적 의사결정",
        "technical1": "• Turborepo 모노레포로 apps 분리 (web, motion-host, proxy)",
        "technical2": "• LegendState Observable 패턴으로 반응형 상태 관리",
        "technical3": "• WebGL GPU 가속으로 CPU 부하 최소화",
        "technical4": "• mediasoup SFU로 다중 클라이언트 확장 가능",
        "learningsTitle": "프로젝트를 통해 배운 점",
        "learning1": "• 저수준 UDP 프로토콜 구현 및 바이너리 데이터 파싱 경험",
        "learning2": "• WebRTC SFU 아키텍처 설계 및 실시간 스트리밍 최적화",
        "learning3": "• 경로 계획 알고리즘의 실제 로봇 제어 적용"
      }
    },
    "akaBrowser": {
      "problem": {
        "title": "aka-browser: 미니 브라우저 개발",
        "subtitle": "프로젝트 개요 및 배경",
        "period": "프로젝트 기간",
        "periodValue": "2025.01 ~ 현재 (진행중)",
        "role": "역할",
        "roleValue": "개인 프로젝트 (100%)",
        "techStack": "기술 스택",
        "techStackValue": "Electron, TypeScript, React, Tailwind CSS",
        "painPointTitle": "사용자 페인 포인트",
        "painPoint1": "• 메인 브라우저를 대체하지 않는 보조 브라우저 필요",
        "painPoint2": "• 항상 위에 고정되어 멀티태스킹 지원",
        "painPoint3": "• Netflix/Disney+ 등 DRM 콘텐츠 재생 가능",
        "quote": "\"작업 중 참고 자료를 보거나 영상을 시청할 때, 메인 브라우저의 탭을 전환하지 않고 항상 위에 띄워둘 수 있는 가벼운 브라우저가 필요.\""
      },
      "design": {
        "title": "aka-browser 설계",
        "subtitle": "시스템 아키텍처",
        "decision1Title": "1. 관심사 분리",
        "decision1Detail1": "• TabManager: 탭 생명주기 관리",
        "decision1Detail2": "• WindowManager: 윈도우 레이아웃 관리",
        "decision1Detail3": "• SecurityManager: URL 검증 + CSP",
        "decision1Detail4": "• BookmarkManager: 즐겨찾기 CRUD",
        "decision2Title": "2. 이벤트 기반 통신",
        "decision2Detail1": "• IPC 채널: 메인 ↔ 렌더러 프로세스 분리",
        "decision2Detail2": "• 타입 안전성: TypeScript 인터페이스 정의",
        "decision2Detail3": "• 보안 검증: 모든 IPC 요청에서 sender 검증",
        "decision3Title": "3. 메모리 최적화",
        "decision3Detail1": "• 비활성 탭: removeChildView()로 렌더링 중단",
        "decision3Detail2": "• LRU 캐시: 테마 컬러 100개 도메인 저장",
        "decision3Detail3": "• 탭 프리뷰: 800x1200 해상도 제한"
      },
      "implementation": {
        "title": "aka-browser 구현",
        "subtitle": "핵심 구현 사항",
        "coreTitle": "핵심 구현 사항",
        "feature1Title": "Widevine DRM 통합",
        "feature1Detail1": "• Castlabs Electron + Component Updater",
        "feature1Detail2": "• EVS VMP 서명 자동화 (afterPack 훅)",
        "feature1Detail3": "• 도메인별 User Agent 전환",
        "feature2Title": "멀티탭 시스템",
        "feature2Detail1": "• WebContentsView 생성 + 이벤트 등록",
        "feature2Detail2": "• 프리뷰 캡처 → 탭 교체 → 테마 적용",
        "feature2Detail3": "• 탭 전환 <100ms, LRU 캐시 최적화",
        "feature3Title": "보안 시스템",
        "feature3Detail1": "• 프로토콜/도메인 검증 + IPC sender 검증",
        "feature3Detail2": "• CSP: 개발/프로덕션 환경 분리",
        "feature4Title": "추가 기능",
        "feature4Detail1": "• 북마크: JSON CRUD + IPC 동기화",
        "feature4Detail2": "• 에러 페이지: 100+ 에러 코드 매핑",
        "challengesTitle": "기술적 도전과 해결",
        "problemLabel": "문제",
        "solutionLabel": "✓ 해결",
        "challenge1Title": "🔴 Widevine 서명 실패",
        "challenge1Problem": "수동 VMP 서명 시 빌드마다 반복 작업 필요",
        "challenge1Solution": "electron-builder afterPack 훅으로 서명 자동화",
        "challenge2Title": "🔴 화면 깜빡임",
        "challenge2Problem": "탭 전환 시 테마 컬러 재계산으로 UI 지연",
        "challenge2Solution": "LRU 캐시로 도메인별 테마 컬러 저장 (100개)",
        "challenge3Title": "🔴 보안 vs 기능",
        "challenge3Problem": "DRM 재생 위해 sandbox 비활성화 필요",
        "challenge3Solution": "프로토콜/도메인/IPC/CSP 4중 검증 체계 구축"
      },
      "results": {
        "title": "aka-browser 결과",
        "subtitle": "프로젝트 성과",
        "metric1Value": "100+",
        "metric1Title": "GitHub Stars",
        "metric1Desc": "오픈소스 공개",
        "metric2Value": "<100ms",
        "metric2Title": "탭 전환 속도",
        "metric2Desc": "LRU 캐시 최적화",
        "metric3Value": "100%",
        "metric3Title": "DRM 재생 성공률",
        "metric3Desc": "Netflix/Disney+/Prime",
        "metric4Value": "4중",
        "metric4Title": "보안 검증",
        "metric4Desc": "프로토콜/도메인/IPC/CSP",
        "achievementsTitle": "정성적 성과",
        "achievement1Title": "✅ 실제 서비스 운영",
        "achievement1": "GitHub 오픈소스 + macOS 배포",
        "achievement2Title": "✅ 기술 부채 관리",
        "achievement2": "TypeScript 엄격 모드 + 모듈화",
        "achievement3Title": "✅ 성능 최적화",
        "achievement3": "LRU 캐시 + 렌더링 최적화",
        "learningsTitle": "프로젝트를 통해 배운 점",
        "learning1Title": "빠른 변화 대응",
        "learning1Detail": "Netflix UA 정책 변경 → 도메인별 UA 전환 (2시간)",
        "learning2Title": "서비스 안정성",
        "learning2Detail": "Widevine 검증 실패 → EVS 서명 자동화",
        "learning3Title": "기술 부채 예방",
        "learning3Detail": "정적 HTML → React TSX 동적 생성",
        "learning4Title": "보안과 기능 균형",
        "learning4Detail": "sandbox 비활성화 → 4중 검증으로 보안 유지"
      }
    },
    "curiosity": {
      "problem": {
        "title": "큐리오시티 개발 배경",
        "subtitle": "비개발자의 빠른 MVP 검증을 위한 온프레미스 AI 코딩 플랫폼",
        "businessProblemTitle": "비즈니스 문제 정의",
        "businessProblemSubtitle": "비개발자의 MVP 검증 장벽",
        "problem1": "• 외주 개발 비용: 최소 500만원 이상, 2-3개월 소요",
        "problem2": "• 노코드 툴의 한계: 커스터마이징 불가능",
        "problem3": "• 개발자 채용: 스타트업 초기 단계에서 인건비 부담",
        "existingToolsTitle": "기존 도구의 한계",
        "existingTool1": "• Cursor/Windsurf: 로컬 환경 설정 필요, 비개발자 진입장벽",
        "existingTool2": "• Bolt.new: 클라우드 종속, 데이터 보안 우려",
        "existingTool3": "• v0.dev: UI 생성만 가능, 백엔드 로직 불가",
        "existingTool4": "• Replit Agent: 클라우드 종속, 온프레미스 불가",
        "quote": "\"비개발자도 아이디어를 즉시 검증할 수 있는, 설치 없이 브라우저에서 바로 실행되는 AI 코딩 플랫폼이 필요.\""
      },
      "design": {
        "title": "큐리오시티 설계",
        "subtitle": "요구사항과 해결 방안",
        "requirement1Title": "1. 비개발자도 즉시 사용 가능한 환경",
        "requirement1Detail1": "→ WebContainer API 기반 브라우저 내 Node.js 환경 구축",
        "requirement1Detail2": "• 로컬 설치 없이 브라우저만으로 즉시 개발 환경 제공",
        "requirement1Detail3": "• 전역 싱글톤 패턴으로 WebContainer 인스턴스 관리",
        "requirement2Title": "2. 데이터 보안을 위한 온프레미스 배포",
        "requirement2Detail1": "→ 자체 호스팅 가능한 API 서버 설계",
        "requirement2Detail2": "• Hono 기반 경량 API 서버로 온프레미스 배포 용이",
        "requirement2Detail3": "• 환경변수 기반 AI 프로바이더 설정",
        "requirement3Title": "3. 실시간 AI 응답으로 빠른 피드백",
        "requirement3Detail1": "→ SSE 기반 스트리밍 응답 시스템 설계",
        "requirement3Detail2": "• AsyncGenerator 패턴으로 토큰 단위 실시간 스트리밍",
        "requirement3Detail3": "• 부분 응답과 완료 응답 분리로 즉각적인 피드백",
        "requirement4Title": "4. AI가 제안한 작업 자동 실행",
        "requirement4Detail1": "→ 재귀적 도구 실행 엔진 설계",
        "requirement4Detail2": "• API 호출 → 도구 실행 → API 호출 무한 반복 구조",
        "requirement4Detail3": "• 반복 패턴 감지 알고리즘으로 무한 루프 방지"
      },
      "implementation": {
        "title": "큐리오시티 구현",
        "subtitle": "기술적 도전과 해결",
        "feature1Title": "1. WebContainer 통합 및 파일시스템 프록시",
        "feature1Detail1": "• 전역 인스턴스 관리: 여러 컴포넌트에서 동일한 WebContainer 재사용",
        "feature1Detail2": "• 다중 경로 시도 로직: /path, path, ./path 등 4가지 형식 자동 시도",
        "feature1Detail3": "• 커스텀 명령어 지원: .curiosity 폴더에 스크립트 배치",
        "feature2Title": "2. 실시간 스트리밍 응답 처리",
        "feature2Detail1": "• AsyncGenerator 기반 스트리밍: OpenAI/Anthropic API 청크 단위 응답",
        "feature2Detail2": "• 부분 메시지 누적: accumulatedText로 토큰 누적 및 실시간 UI 업데이트",
        "feature2Detail3": "• 비용 및 시간 추적: 최종 응답에서 토큰 사용량 기반 비용 계산",
        "feature3Title": "3. 재귀적 도구 실행 자동화",
        "feature3Detail1": "• 무제한 깊이 재귀: processMessageRecursively(depth) 함수로 도구 체인 자동 실행",
        "feature3Detail2": "• 반복 패턴 감지: 최근 5회 히스토리 추적, 동일 패턴 3회 반복 시 중단",
        "feature3Detail3": "• 개별 도구 타임아웃: 각 도구 실행에 30초 타임아웃 적용",
        "decisionTitle": "기술적 의사결정",
        "decision1": "• 빠른 MVP vs 완벽한 설계: 재귀 패턴으로 복잡도 감소",
        "decision2": "• 성능 vs 안정성: 타임아웃과 반복 감지로 안정성 우선",
        "decision3": "• 클라우드 vs 온프레미스: 데이터 보안을 위해 온프레미스 우선 설계"
      },
      "results": {
        "title": "큐리오시티 결과",
        "subtitle": "비즈니스 임팩트 및 성과",
        "metric1Value": "100%",
        "metric1Title": "브라우저 실행",
        "metric1Desc": "설치 없이 즉시 사용",
        "metric2Value": "10초",
        "metric2Title": "평균 응답 시간",
        "metric2Desc": "AI 코드 생성",
        "metric3Value": "30+",
        "metric3Title": "지원 도구",
        "metric3Desc": "파일/명령/검색 등",
        "learningsTitle": "프로젝트를 통해 배운 점",
        "architectureTitle": "아키텍처 설계",
        "architecture1": "• WebContainer 싱글톤 패턴으로 리소스 효율성 극대화",
        "architecture2": "• 재귀 구조로 복잡한 비즈니스 로직을 단순하게 표현",
        "architecture3": "• 클라이언트-서버 도구 분리로 확장 가능한 구조 설계",
        "balanceTitle": "안정성과 사용성의 균형",
        "balance1": "• 무한 재귀의 위험성을 패턴 감지로 해결",
        "balance2": "• 개별 도구 실패가 전체 플로우를 중단시키지 않도록 설계",
        "balance3": "• 비개발자도 이해할 수 있는 직관적인 피드백 제공",
        "discontinuedTitle": "아쉬운 점 및 중단 사유",
        "discontinuedSubtitle": "프로젝트 중단 (2025년 9월 12일)",
        "discontinued1": "• 온프레미스 LLM 통합 작업 미완료",
        "discontinued2": "• 외부 API 의존성 제거 목표 미달성",
        "discontinued3": "• 라미앱 프로젝트로 리소스 집중",
        "futureTitle": "향후 개선 방향 (중단 전 계획)",
        "future1": "• 온프레미스 LLM 서버 통합",
        "future2": "• 폐쇄망 환경 완전 독립 실행",
        "future3": "• 도구 실행 병렬화"
      }
    }
  },
  "sideProjects": {
    "hero": {
      "title": "사이드 프로젝트",
      "subtitle": "오픈소스 라이브러리 컬렉션",
      "description": "개발하면서 필요했던 기능들을 범용적인 오픈소스 라이브러리로 만들어 공개했습니다. 각 프로젝트는 실제 문제를 해결하기 위해 설계되었으며, TypeScript로 작성되어 타입 안정성을 보장합니다.",
      "websiteLink": "웹사이트",
      "backToResume": "이력서로 돌아가기"
    },
    "projects": {
      "mugunghwa": {
        "title": "무궁화",
        "description": "영어와 숫자를 혼합한 32진법 Base 32를 모방해 순수 한글로 72진법 인코드 체계 개발한 오픈소스 모듈입니다."
      },
      "biggest": {
        "title": "Biggest",
        "description": "2kb의 가벼운 크기로 무한 정밀도의 큰 정수와 큰 소수를 안전하게 계산할 수 있는 라이브러리입니다."
      },
      "pseudoShuffle": {
        "title": "Pseudo Shuffle",
        "description": "실제로 섞지 않고도 범위에 따라 섞인 것처럼 보이는 인덱스를 만드는 결정론적 유사난수 셔플 라이브러리입니다."
      },
      "edgeCrypto": {
        "title": "Edge Crypto",
        "description": "Node.js, 브라우저, Cloudflare Workers에서 외부 의존성 없이 사용할 수 있는 통합 SubtleCrypto 유틸리티입니다."
      },
      "gaussSpiral": {
        "title": "Gauss Spiral",
        "description": "중심에서 바깥으로 원을 점으로 채우는 나선형 열거를 위한 (x, y) ↔ n 매핑을 효율적으로 계산합니다."
      },
      "curseScript": {
        "title": "Curse Script",
        "description": "코드를 주문과 같은 난독화된 문법으로 변환하는 JavaScript 난독화 도구입니다."
      },
      "akaBrowser": {
        "title": "Aka Browser",
        "description": "크로미엄 엔진 기반으로 오픈소스 브라우저를 만들었습니다. 메인 브라우저를 대체하지 않고 항상 위에 고정되는 보조 브라우저 컨셉이며, 일렉트론으로 베타 출시까지 완료했습니다. Widevine DRM 기반으로 Netflix/Disney+/Prime Video의 암호화 콘텐츠 스트리밍 재생을 구현했습니다."
      }
    },
    "mugunghwa": {
      "pageTitle": "무궁화 - 한글 기반 72진법 인코딩 라이브러리",
      "pageDescription": "10진수 숫자를 한글로 인코딩/디코딩하는 TypeScript 라이브러리",
      "title": "🌺 무궁화",
      "subtitle": "한글 기반 72진법 인코딩 라이브러리",
      "introduction": "무궁화는 10진수 숫자를 한글로 인코딩/디코딩하는 TypeScript 라이브러리입니다. 한글의 특성을 활용하여 숫자를 간결하고 읽기 쉬운 한글 문자열로 변환합니다.",
      "features": "특징",
      "feature1": "72진법 기반: 한글 조합을 활용한 효율적인 숫자 인코딩",
      "feature2": "비속어 필터링: 부적절한 단어 조합을 자동으로 배제",
      "feature3": "양방향 변환: 숫자 ↔ 한글 문자열 상호 변환 지원",
      "feature4": "오타 보정: 유사한 글자의 오타를 자동으로 수정",
      "feature5": "TypeScript 지원: 완전한 타입 정의 제공",
      "installation": "설치",
      "copy": "복사",
      "copied": "복사됨!",
      "copyTitle": "복사",
      "usageExample": "사용 예시",
      "usageComment1": "// 숫자를 한글로 인코딩",
      "usageComment2": "// 한글을 숫자로 디코딩",
      "howItWorks": "작동 원리",
      "whatIsMugunghwa": "무궁화 코드란?",
      "whatIsMugunghwaDesc1": "무궁화코드는 한글로 숫자를 표현하는 코드체계입니다.",
      "whatIsMugunghwaDesc2": "숫자만의 적은 길이로 더 수를 표현할 수 있게 해줍니다.",
      "principle": "무궁화 코드 원리",
      "principleDesc1": "무궁화코드는 10개 숫자로 10진법을 이루는 것 처럼",
      "principleDesc2": "84개의 한글글자로 72진법을 구성하고 있습니다.",
      "koreanCharacters": "84개 한글글자",
      "encodingMethod": "무궁화 코드의 인코딩 방식",
      "encodingMethodDesc1": "10진법을 72진법으로 변환할 때, 2글자씩 묶어서 5184진법으로 끊은 후,",
      "encodingMethodDesc2": "마지막에 글자가 하나 남으면 해당 글자만 72진법으로 하향 표기합니다.",
      "encodingMethodDetail1": "84진법 2글자 조합: 84² = 7,056개",
      "encodingMethodDetail2": "72진법 2글자 조합: 72² = 5,184개",
      "profanityFiltering": "비속어 필터링 전략",
      "profanityFilteringDesc1": "무궁화코드는 84진법 중 검사 조합에서 1872개의 조합을 배제하는",
      "profanityFilteringDesc2": "과정을 통해서 발생가능한 비속어나 발음하기 어려운 단어 노출을 방지합니다.",
      "relatedPaper": "관련 논문",
      "paperTitle": "음절 블록 체계를 이용한 한글에서의 72진법 표현 체계",
      "author": "저자: 진환",
      "publisher": "출판사: 한국통신학회",
      "publishDate": "출간일: 2019년",
      "paperDescription": "영어와 숫자를 혼합한 32진법 Base 32를 모방해 순수 한글로 72진법 인코드 체계 개발. 3미터 오차의 GPS 좌표를 한글 다섯자리로 압축하는 알고리즘 제안. 이 논문을 토대로 JavaScript 기반 오픈소스 구현체 '무궁화 코드' 개발 및 GitHub 공개.",
      "paper": "Paper",
      "downloadSection": "무궁화 코드 전체 조합 다운로드",
      "downloadDescription": "비속어가 필터링된 5,184개의 무궁화 코드 조합을 다운로드할 수 있습니다. 이름 작명, 코드 생성 등 다양한 용도로 활용하실 수 있습니다.",
      "downloadButton": "84_filtered.txt 다운로드",
      "github": "GitHub",
      "wiki": "Wiki",
      "npm": "NPM",
      "license": "MIT License © hmmhmmhm",
      "experience": "체험",
      "encode": "암호화",
      "decode": "복호화",
      "mugunghwaCode": "무궁화 코드",
      "decodedNumber": "디코딩된 숫자",
      "numberToConvert": "코드로 변환될 숫자",
      "codeToConvert": "숫자로 변환될 무궁화 코드",
      "enterNumber": "숫자를 입력하세요",
      "enterCode": "무궁화 코드를 입력하세요",
      "randomNumber": "랜덤 숫자 생성",
      "randomCode": "랜덤 코드 생성"
    },
    "biggest": {
      "pageTitle": "Biggest - 무한 정밀도 계산 라이브러리",
      "pageDescription": "2kb의 가벼운 크기로 무한 정밀도의 큰 정수와 큰 소수를 안전하게 계산할 수 있는 라이브러리",
      "project": "프로젝트",
      "title": "Biggest",
      "subtitle": "2kb의 가벼운 크기로 무한 정밀도의 큰 정수와 큰 소수를 안전하게 계산할 수 있는 라이브러리입니다.",
      "installation": "설치",
      "copy": "복사",
      "copied": "복사됨!",
      "copyTitle": "복사",
      "add": "큰수 덧셈",
      "subtract": "큰수 뺄셈",
      "multiply": "큰수 곱셈",
      "divide": "큰수 나눗셈",
      "invalidExpression": "잘못된 계산식",
      "error": "오류",
      "calculationFailed": "계산 실패",
      "keyFeatures": "주요 기능",
      "basicOperations": "기본 연산",
      "basicOperationsDesc": "덧셈, 뺄셈, 곱셈, 나눗셈",
      "comparisonOperations": "비교 연산",
      "comparisonOperationsDesc": "크기 비교, 최소/최대값 찾기",
      "rounding": "반올림",
      "roundingDesc": "floor, ceil, round 등",
      "power": "거듭제곱",
      "powerDesc": "제곱근, n제곱근 계산",
      "modular": "모듈러 연산",
      "modularDesc": "mod, gcd, lcm 계산",
      "combinatorics": "조합론",
      "combinatoricsDesc": "팩토리얼, 조합, 순열 계산",
      "whyBiggest": "왜 Biggest를 사용해야 하나요?",
      "infinitePrecision": "무한 정밀도",
      "infinitePrecisionDesc": "JavaScript의 숫자 제한을 넘어 임의의 크기의 정수와 소수를 처리",
      "lightweight": "가벼운 크기",
      "lightweightDesc": "단 2kb의 크기로 의존성 없이 순수 문자열 기반 구현",
      "perfectAccuracy": "완벽한 정확성",
      "perfectAccuracyDesc": "부동소수점 오류 없이 금융, 과학 계산 등에 안전하게 사용",
      "usageExample": "사용 예시",
      "basicUsage": "기본 연산",
      "advancedUsage": "고급 연산",
      "comparisonComment": "// 비교 연산",
      "roundingComment": "// 반올림 연산",
      "powerComment": "// 거듭제곱 연산",
      "modularComment": "// 모듈러 연산",
      "combinatoricsComment": "// 조합론",
      "github": "GitHub",
      "npm": "NPM",
      "license": "MIT License © hmmhmmhm"
    },
    "pseudoShuffle": {
      "pageTitle": "Pseudo Shuffle - FPE 동형암호화 기반 유사난수 셔플 라이브러리",
      "pageDescription": "실제로 섞지 않고도 섞인 것처럼 보이는 인덱스를 계산하는 TypeScript 라이브러리",
      "title": "Pseudo Shuffle",
      "subtitle": "FPE 동형암호화 기반 유사난수 셔플 라이브러리",
      "introduction": "Pseudo Shuffle은 FPE(Format-Preserving Encryption) 동형암호화 알고리즘을 활용하여 매우 큰 범위의 인덱스를 실제로 섞지 않고도 섞인 것처럼 보이게 만드는 TypeScript 라이브러리입니다. DB나 메모리를 사용하지 않고도 유사난수 개념으로 겹치지 않는 셔플된 인덱스를 즉시 계산할 수 있습니다.",
      "installation": "설치",
      "copy": "복사",
      "copied": "복사됨!",
      "copyTitle": "복사",
      "features": "특징",
      "feature1": "FPE 암호화: Format-Preserving Encryption으로 안전한 셔플",
      "feature2": "메모리 효율: DB나 배열 없이 즉시 계산",
      "feature3": "충돌 방지: 같은 범위 내에서 절대 겹치지 않음",
      "feature4": "양방향 변환: 인코딩/디코딩 모두 지원",
      "feature5": "TypeScript 지원: 완전한 타입 정의 제공",
      "useCases": "활용 사례",
      "useCase1Title": "단축 URL 생성",
      "useCase1Desc": "DB 없이 순차적인 ID를 무작위로 보이는 짧은 URL로 변환. 예측 불가능하면서도 충돌 없는 단축 링크 생성",
      "useCase2Title": "유저 번호 암호화",
      "useCase2Desc": "순차적인 유저 ID를 암호화하여 노출. 길이가 변하지 않아 기존 시스템과 호환성 유지",
      "useCase3Title": "개인정보 보호",
      "useCase3Desc": "주민번호, 전화번호 등 고정 길이 데이터를 형식 유지하며 암호화. FPE 특성으로 원본 형식 그대로 보호",
      "useCase4Title": "쿠폰/티켓 번호",
      "useCase4Desc": "순차 발급되는 쿠폰 번호를 무작위처럼 보이게 변환. 발급 순서 추측 방지 및 보안 강화",
      "usageExample": "사용 예시",
      "encodeComment": "// 인덱스 인코딩",
      "decodeComment": "// 인덱스 디코딩",
      "howItWorks": "작동 원리",
      "whatIsPseudoShuffle": "Pseudo Shuffle란?",
      "whatIsPseudoShuffleDesc1": "실제로 데이터를 섞지 않고, 유사난수(Pseudo Random) 개념을 활용하여",
      "whatIsPseudoShuffleDesc2": "주어진 범위 내에서 인덱스가 섞인 것처럼 보이게 만드는 기술입니다.",
      "whatIsPseudoShuffleDesc3": "같은 인덱스는 항상 같은 값으로 변환되며, 충돌이 발생하지 않습니다.",
      "fpeEncryption": "FPE 암호화",
      "fpeEncryptionDesc1": "Format-Preserving Encryption을 사용하여 입력 형식을 유지하면서",
      "fpeEncryptionDesc2": "암호화된 값을 생성합니다. 이를 통해 예측 불가능하면서도",
      "fpeEncryptionDesc3": "결정론적인 셔플 결과를 얻을 수 있습니다.",
      "warnings": "주의사항",
      "warning1": "⚠️ 진짜 난수가 아닌 유사난수입니다. 암호학적 보안이 필요한 경우 privateKey를 설정하세요.",
      "warning2": "⚠️ min과 max 값의 차이가 최소 4 이상이어야 셔플이 적용됩니다.",
      "warning3": "✅ 이 라이브러리는 node-fe1-fpe 라이브러리를 기반으로 만들어졌습니다.",
      "github": "GitHub",
      "npm": "NPM",
      "license": "MIT License © hmmhmmhm"
    },
    "edgeCrypto": {
      "pageTitle": "Edge Crypto - Universal SubtleCrypto toolkit",
      "pageDescription": "Encrypt, sign, hash, and manage RSA keys across Node.js, browsers, Cloudflare Workers, Deno, and Bun.",
      "title": "Edge Crypto",
      "subtitle": "통합 SubtleCrypto 유틸리티",
      "introduction": "Edge Crypto는 Node.js, 브라우저, Cloudflare Workers, Deno, Bun 등 모든 JavaScript 런타임에서 외부 의존성 없이 사용할 수 있는 통합 암호화 유틸리티 라이브러리입니다. Web Crypto API를 기반으로 일관된 인터페이스를 제공합니다.",
      "features": "특징",
      "feature1": "크로스 플랫폼: 모든 JavaScript 런타임 지원",
      "feature2": "제로 의존성: 외부 라이브러리 없이 동작",
      "feature3": "Web Crypto API: 표준 API 기반",
      "feature4": "RSA 지원: 키 생성, 암호화, 서명",
      "feature5": "TypeScript 지원: 완전한 타입 정의 제공",
      "installation": "설치",
      "usage": "사용법",
      "basicUsage": "기본 사용",
      "advancedUsage": "고급 사용",
      "links": "링크",
      "github": "GitHub",
      "npm": "NPM",
      "documentation": "문서"
    },
    "gaussSpiral": {
      "pageTitle": "Gauss Spiral - 나선 좌표 시스템 라이브러리",
      "pageDescription": "나선형으로 회전하며 픽셀을 채우는 효율적인 좌표 시스템의 좌표를 계산합니다.",
      "title": "Gauss Spiral",
      "subtitle": "나선 좌표 시스템 라이브러리",
      "introduction": "Gauss Spiral은 중심에서 바깥으로 원을 점으로 채우는 나선형 열거를 위한 (x, y) ↔ n 매핑을 효율적으로 계산하는 TypeScript 라이브러리입니다. 2D 공간의 점들을 나선형으로 순회하거나 인덱스를 좌표로 변환할 때 유용합니다.",
      "features": "특징",
      "feature1": "양방향 변환: 좌표 ↔ 인덱스 상호 변환",
      "feature2": "효율적: O(√N) 시간 복잡도",
      "feature3": "나선형 순회: 중심에서 바깥으로 확장",
      "feature4": "수학적 정확성: Gauss 알고리즘 기반",
      "feature5": "TypeScript 지원: 완전한 타입 정의 제공",
      "useCases": "사용 사례",
      "useCase1": "이미지 처리: 중심에서 바깥으로 픽셀 처리",
      "useCase2": "게임 개발: 나선형 맵 생성 및 탐색",
      "useCase3": "데이터 시각화: 나선형 레이아웃",
      "useCase4": "알고리즘: 공간 분할 및 탐색",
      "installation": "설치",
      "usage": "사용법",
      "basicUsage": "기본 사용",
      "advancedUsage": "고급 사용",
      "links": "링크",
      "github": "GitHub",
      "npm": "NPM",
      "documentation": "문서",
      "spiralViewer": "나선 좌표 시각화",
      "spiralTransform": "나선 좌표 변환",
      "explanation": "설명",
      "explanationText1": "중심 픽셀 (0, 0)에서 시작하여 바깥쪽으로 확장하면서 점을 그려 원이 빈틈없이 채워지는 것을 상상해보세요. 이 라이브러리는 다음 사항을 계산할 수 있습니다:",
      "explanationItem1": "• 점의 좌표 (x, y)가 주어지면, 정확히 몇 번째 턴 n에 배치되었는지",
      "explanationItem2": "• 단계 n이 주어지면, 다음에 그릴 정확한 좌표 (x, y)",
      "explanationText2": "픽셀 플로팅, 파티클 시스템, 절차적 아트 또는 중심에서 바깥으로 확장하는 결정론적 나선 채우기가 필요한 모든 시각화에 유용합니다.",
      "featuresTitle": "특징",
      "featureDeterministic": "결정론적 매핑",
      "featureDeterministicDesc": "모든 격자점에 대해 안정적이고 재현 가능한 순서",
      "featureBidirectional": "양방향 변환",
      "featureBidirectionalDesc": "(x, y) → n 및 n → (x, y) 모두 변환 가능",
      "featureGeometry": "기하학 우선",
      "featureGeometryDesc": "간단한 산술과 atan2 정렬, 복잡한 정수론 불필요",
      "featureProgressive": "점진적 렌더링 친화적",
      "featureProgressiveDesc": "점진적 렌더링이나 스트리밍 업데이트에 적합",
      "featureRingSampling": "링 샘플링",
      "featureRingSamplingDesc": "효과 및 배칭을 위해 반경 링별로 점을 쉽게 반복",
      "featureZeroDeps": "의존성 제로",
      "featureZeroDepsDesc": "순수 TypeScript/JavaScript, 작은 번들 크기",
      "copy": "복사",
      "copied": "복사됨!",
      "copyTitle": "복사",
      "usageExample": "사용 예시",
      "usageComment1": "// (x, y)에서 n 구하기",
      "usageComment2": "// n에서 (x, y) 구하기",
      "practicalExamples": "실용적인 예시",
      "exampleVisual": "시각 효과 / 렌더링",
      "exampleVisualDesc1": "점진적 방사형 표시, 나선형 파티클 방출, 후광 확장 효과",
      "exampleVisualDesc2": "n = 1..N을 반복하고 getCoordinates(n)을 플롯하여 x² + y²가 반경을 초과하면 중지",
      "exampleGIS": "GIS / 지도 타일링",
      "exampleGISDesc1": "중심 타일 (cx, cy) 주변의 타일을 나선 순서로 우선 가져와 체감 반응성을 극대화",
      "exampleGISDesc2": "getCoordinates(n)을 (cx, cy)의 오프셋으로 사용",
      "exampleGame": "게임 / 청크 가시성 및 로딩",
      "exampleGameDesc1": "플레이어 주변의 청크를 원형 우선 방식으로 로드하여 다이아몬드 또는 사각형 모양의 아티팩트 방지",
      "exampleGameDesc2": "getCoordinates(n)으로 로딩 순서를 계산하거나 getNFromCoordinates(dx, dy)를 통해 알려진 청크에 우선순위 할당",
      "howItWorks": "작동 원리",
      "problemDefinition": "문제 정의",
      "problemDefinitionDesc": "원점에서 바깥쪽으로 점점 커지는 나선으로 정수 점을 플로팅할 때:",
      "problemItem1": "• 주어진 (x, y)에 대한 n (방문 인덱스) 결정",
      "problemItem2": "• 주어진 n에 대한 (x, y) (단계 n에서 방문한 좌표) 결정",
      "approach": "접근 방식",
      "approachDesc1": "제곱 반경 m = x² + y²로 점을 그룹화합니다 (동심원 \"링\"). 각 링 내에서 점들은 시계 방향으로 극각 atan2(y, x)로 정렬됩니다.",
      "approachDesc2": "전역 인덱스 n은 더 작은 m을 가진 모든 점의 누적 개수와 현재 링 내 위치의 합입니다.",
      "algorithmOverview": "알고리즘 개요",
      "algorithmRing": "링",
      "algorithmRingDesc": "각 정수 m ≥ 0에 대해 링은 x² + y² = m의 모든 정수 해를 포함",
      "algorithmOrder": "링 내 순서",
      "algorithmOrderDesc": "atan2(y, x) 내림차순(시계방향)으로 해를 정렬",
      "algorithmGlobalIndex": "전역 인덱스",
      "algorithmGlobalIndexDesc": "S(m)을 x² + y² ≤ m인 정수 점의 개수라 하면, x² + y² = m인 (x, y)에 대해 n = S(m-1) + k (k는 링에서의 1기반 위치)",
      "algorithmInverse": "역변환 (n → (x, y))",
      "algorithmInverseDesc": "S(m) ≥ n인 최소 m을 이진 탐색하고, k = n - S(m-1)로 설정하여 위와 같이 정렬된 링의 k번째 점 반환",
      "api": "API",
      "apiGetNDesc": "나선 열거에서 (x, y)의 1기반 방문 인덱스 n을 반환합니다.",
      "apiGetCoordsDesc": "단계 n에서 방문한 격자 좌표를 반환합니다. (n은 0보다 커야 함)",
      "performanceNotes": "성능 참고사항",
      "performanceNote1": "• S(m) 카운팅은 대칭을 사용하여 x당 격자점을 집계하는 O(√m)으로 구현됩니다",
      "performanceNote2": "• n → (x, y)는 초기 추측 주변의 m에 대한 이진 탐색을 사용한 다음 해당 m에 대한 링 점만 정렬합니다",
      "spiralViewerTitle": "나선 좌표 시각화",
      "spiralViewerDesc": "이 시각화는 (0,0)에서 시작하여 시계 방향으로 바깥쪽으로 확장되는 독특한 나선 좌표 시스템을 보여줍니다. 슬라이더를 움직여 1부터 좌표를 생성하고, 원점 주위에 동심원 레이어를 형성하는 모습을 관찰하세요.",
      "gridRange": "그리드 범위",
      "coordinateRange": "좌표 범위",
      "spiralTransformTitle": "나선 좌표 변환",
      "error": "오류"
    },
    "curseScript": {
      "pageTitle": "Curse Script - JavaScript Obfuscator",
      "pageDescription": "A JavaScript obfuscator that converts code into cursed spell-like syntax using ancient characters",
      "title": "Curse Script",
      "subtitle": "JavaScript 난독화 도구",
      "introduction": "Curse Script는 JavaScript 코드를 주문과 같은 난독화된 문법으로 변환하는 재미있는 난독화 도구입니다. 고대 문자와 특수 기호를 사용하여 코드를 읽을 수 없게 만들면서도 정상적으로 실행되도록 합니다.",
      "features": "특징",
      "feature1": "다양한 문자 세트: 룬 문자, 고대 페르시아어, 이모지 또는 사용자 정의 문자",
      "feature2": "완전한 난독화: JavaScript를 읽을 수 없지만 실행 가능한 코드로 변환",
      "feature3": "TypeScript 지원: 완전한 타입 정의 포함",
      "feature4": "사용자 정의 문자: 난독화에 모든 유니코드 문자 사용 가능",
      "feature5": "실행 가능한 출력: 생성된 코드는 모든 JavaScript 환경에서 실행됨",
      "installation": "설치",
      "copy": "복사",
      "copied": "복사됨!",
      "copyTitle": "복사",
      "tryItOut": "체험하기",
      "characterSet": "문자 세트",
      "javascriptCode": "JavaScript 코드",
      "randomExample": "랜덤 예제",
      "enterCode": "JavaScript 코드를 입력하세요 (예: console.log(\"Hello\"))",
      "cursedOutput": "난독화된 출력",
      "usageExample": "사용 예시",
      "defaultComment": "// 기본: 룬 문자 사용",
      "oldPersianComment": "// 고대 페르시아 문자 사용",
      "howItWorks": "작동 원리",
      "characterSetOptions": "문자 세트 옵션",
      "runic": "룬 문자",
      "runicDesc": "신비로운 난독화를 위해 고대 룬 문자(ᚠ-ᚷ) 사용",
      "oldPersian": "고대 페르시아",
      "oldPersianDesc": "고대 코드 미학을 위해 쐐기 문자(𐎠-𐎷) 사용",
      "emoji": "이모지",
      "emojiDesc": "재미있는 난독화를 위해 코드를 이모지 시퀀스(😀-😗)로 변환",
      "none": "없음",
      "noneDesc": "특수 문자 없이 기본 난독화를 위해 라틴 문자(A-X) 사용",
      "customCharacterSets": "사용자 정의 문자 세트",
      "customCharacterSetsDesc1": "최소 24개의 고유한 유니코드 문자로 구성된 배열을 제공할 수 있습니다.",
      "customCharacterSetsDesc2": "문자는 순서대로 변수 A-X에 매핑되어 완전한 사용자 정의가 가능합니다.",
      "obfuscationProcess": "난독화 과정",
      "obfuscationProcessDesc1": "단순히 식별자 이름을 바꾸거나 문자열을 gzip으로 압축하는 기존 난독화 도구와 달리, Curse Script는 모든 조각을 코드 골프 방식으로 압축하여 페이로드에 원본 프로그램의 읽을 수 있는 흔적이 남지 않도록 합니다.",
      "obfuscationProcessDesc2": "프렐루드는 <code>A = ''</code>와 같은 최소한의 할당으로 시작한 다음 강제 변환을 남용하여(예: <code>B = !A + A</code>, <code>D = A + { }</code>) <code>\"true\"</code>, <code>\"false\"</code>, <code>\"[object Object]\"</code>와 같은 단어를 직접 입력하지 않고 추출합니다.",
      "obfuscationProcessDesc3": "수집된 부분 문자열은 재결합되어 중요한 토큰을 합성합니다: <code>E = B[A++]</code>는 문자 \"t\"를 추출하고, <code>I = D[G+H]</code>는 \"constructor\"를 드러내며, 이를 <code>J(...)</code> 안에 쌓으면 부작용만으로 <code>Function</code> 생성자에 대한 참조를 생성합니다.",
      "obfuscationProcessDesc4": "각 소스 문자는 이러한 골프 변수를 통해 재표현됩니다—일반적인 글리프는 조회 테이블에서 가져오고, 나머지는 천체 기호의 서로게이트 쌍도 처리하는 유니코드 이스케이프 표현식을 통해 필요에 따라 재구성됩니다.",
      "obfuscationProcessDesc5": "모든 조각은 <code>J(... )();</code>로 연결되어 합성된 <code>Function</code>을 호출합니다; 최종 패스는 선택적으로 변수 <code>A</code>–<code>X</code>를 룬 문자, 고대 페르시아어, 이모지 또는 사용자 정의 글리프로 다시 매핑하여 스크립트를 실행 가능하게 유지하면서 주문과 같은 모양을 확정합니다.",
      "usage": "사용법",
      "basicUsage": "기본 사용",
      "advancedUsage": "고급 사용",
      "links": "링크",
      "github": "GitHub",
      "wiki": "Wiki",
      "npm": "NPM",
      "license": "MIT License © hmmhmmhm",
      "documentation": "문서"
    }
  }
}
